## 目标
- 基于现有 `orders` 表，最小改动实现两件事：
  1) 买家在“我买到的”点击“去支付”，填写收件信息并确认，订单置为 `PAID`
  2) 卖家在“我卖出的”点击“去发货”，填写物流信息，订单置为 `SHIPPED`
- 保持已存在“确认收货”（`RECEIVED`）逻辑；不改动数据库结构

## 字段映射
- 买家支付填写：`receiver_name`、`receiver_phone`、`receiver_address`（orders 表）
- 卖家发货填写：`shipping_company`、`shipping_no`、同时设置 `shipped_at=NOW()`（orders 表）
- 确认收货：设置 `received_at=NOW()`，状态改为 `RECEIVED`

## 后端接口（最小实现）
1) 修改：`POST /api/order/pay/{id}`
- 请求体：`{ receiver_name, receiver_phone, receiver_address }`
- 条件：当前用户为 `buyer_id`，且 `status='PENDING'`
- 行为：更新三项收件信息，`status='PAID'`
- 返回：`Result.ok()`

2) 新增：`POST /api/order/ship/{id}`
- 请求体：`{ shipping_company, shipping_no }`
- 条件：当前用户为 `seller_id`，且 `status='PAID'`
- 行为：更新物流公司与单号，`status='SHIPPED'`，`shipped_at=NOW()`
- 返回：`Result.ok()`

3) 已有：`POST /api/order/received/{id}`（保留）
- 条件：当前用户为 `buyer_id`，且 `status='SHIPPED'`
- 行为：`status='RECEIVED'`，`received_at=NOW()`

4) 可选（不必须）：`POST /api/order/cancel/{id}`（`PENDING`→`CANCELLED`，仅买家）

### 校验简化
- 非空校验 + 长度限制：
  - `receiver_name`≤100、`shipping_company`≤50、`shipping_no`≤100
  - `receiver_phone`≤20（可用简单手机号/座机正则）
- 权限校验：`buyer_id/seller_id` 比对 `request.userId`
- 状态机：只允许 `PENDING→PAID→SHIPPED→RECEIVED` 的顺序

## 前端改动（最小 UI）
1) 我买到的（`OrderListBuy.vue`）
- 在 `status==='PENDING'` 行显示“去支付”按钮
- 点击弹出对话框表单：收件人、手机号、收件地址（`el-form` + 简单规则）
- 提交调用 `POST /api/order/pay/{id}`，成功后关闭弹窗并刷新列表
- 在 `status==='SHIPPED'` 显示“确认收货”，调用 `POST /api/order/received/{id}`

2) 我卖出的（`OrderListSell.vue`）
- 在 `status==='PAID'` 行显示“去发货”按钮
- 点击弹出对话框表单：物流公司、物流单号（`el-form` + 简单规则）
- 提交调用 `POST /api/order/ship/{id}`，成功后关闭弹窗并刷新列表
- 在 `status==='SHIPPED'` 显示物流信息（只读）

### 交互与提示
- 所有请求失败弹 `ElMessage.error`，成功弹 `ElMessage.success`
- 表单 `loading` 状态与按钮禁用
- 列表刷新保留当前分页

## 验收
- 构造一条 `PENDING` 订单：买家“去支付”后变 `PAID` 且收件信息持久化
- 卖家“去发货”后变 `SHIPPED` 且物流信息与发货时间持久化
- 买家“确认收货”后变 `RECEIVED` 且收货时间持久化
- 非法用户或错误状态返回错误并不改数据

## 实施顺序
1) 后端：调整 `pay`、新增 `ship`；在 Service 层加字段更新与校验
2) 前端：在两个订单列表增加弹窗表单与调用逻辑
3) 联调：覆盖三个状态流转，功能正常即可